import logging
from typing import Callable, Dict, List, Optional, Set, Tuple, Union

from large_cohort.frequencies import POPS_TO_REMOVE_FOR_POPMAX

import hail as hl

from cpg_workflows.utils import can_reuse, config_retrieve
from gnomad.utils import filter_arrays_by_meta, make_freq_index_dict_from_meta
from gnomad.utils.annotations import (
    merge_freq_arrays,
    merge_histograms,
)

logging.basicConfig(format="%(levelname)s (%(name)s %(lineno)s): %(message)s")
logger = logging.getLogger("compute_combined_faf")
logger.setLevel(logging.INFO)


GEN_ANC_GROUPS_TO_REMOVE_FOR_GRPMAX = {"Unassigned"}
DATA_TYPES = ["exomes", "genomes"]
FAF_POPS = ['CSA', 'EAS', 'EUR']  # We can only perform this test for populations in both datasets


def gen_anc_faf_max_expr(
    faf: hl.expr.ArrayExpression,
    faf_meta: hl.expr.ArrayExpression,
    gen_anc_label: str = "gen_anc",
) -> hl.expr.StructExpression:
    """
    Retrieve the maximum FAF and corresponding genetic ancestry for each of the thresholds in `faf`.

    This resulting struct contains the following fields:

        - faf95_max: float64
        - faf95_max_gen_anc: str
        - faf99_max: float64
        - faf99_max_gen_anc: str

    :param faf: ArrayExpression of Structs of FAF thresholds previously computed. When
        `faf_expr` is used, contains fields 'faf95' and 'faf99'.
    :param faf_meta: ArrayExpression of meta dictionaries corresponding to faf (as
        returned by faf_expr)
    :param gen_anc_label: Label of the genetic ancestry group field in the meta dictionary
    :return: Genetic ancestry group struct for FAF max
    """
    faf_gen_anc_indices = hl.enumerate(faf_meta).filter(
        lambda i: (hl.set(i[1].keys()) == {"group", gen_anc_label}) & (i[1]["group"] == "adj"),
    )
    max_fafs_expr = hl.struct()

    # Iterate through faf thresholds, generally 'faf95' and 'faf99', and
    # take the maximum faf value, '[0]', and its gen_anc from the sorted faf array
    for threshold in faf[0].keys():
        faf_struct = hl.sorted(
            faf_gen_anc_indices.map(
                lambda x: {
                    f"{threshold}_max": hl.or_missing(faf[x[0]][threshold] > 0, faf[x[0]][threshold]),
                    f"{threshold}_max_gen_anc": hl.or_missing(faf[x[0]][threshold] > 0, x[1][gen_anc_label]),
                },
            ),
            key=lambda faf: faf[f"{threshold}_max"],
            reverse=True,
        )

        faf_struct = hl.if_else(hl.len(faf_struct) > 0, faf_struct[0], hl.missing(faf_struct.dtype.element_type))

        max_fafs_expr = max_fafs_expr.annotate(**faf_struct)

    return max_fafs_expr


def faf_expr(
    freq: hl.expr.ArrayExpression,
    freq_meta: hl.expr.ArrayExpression,
    locus: hl.expr.LocusExpression,
    gen_anc_groups_to_exclude: Optional[Set[str]] = None,
    faf_thresholds: List[float] = [0.95, 0.99],
    gen_anc_label: str = "gen_anc",
) -> Tuple[hl.expr.ArrayExpression, List[Dict[str, str]]]:
    """
    Calculate the filtering allele frequency (FAF) for each threshold specified in `faf_thresholds`.

    See http://cardiodb.org/allelefrequencyapp/ for more information.

    The FAF is computed for each of the following genetic ancestry group stratification if found in `freq_meta`:

        - All samples, with adj criteria
        - For each genetic ancestry group, with adj criteria
        - For all sex/genetic ancestry group on the non-PAR regions of sex chromosomes (will be missing on autosomes and PAR regions of sex chromosomes)

    Each of the FAF entry is a struct with one entry per threshold specified in `faf_thresholds` of type float64.

    This returns a tuple with two expressions:

        1. An array of FAF expressions as described above
        2. An array of dict containing the metadata for each of the array elements, in the same format as that produced by `annotate_freq`.

    :param freq: ArrayExpression of call stats structs (typically generated by hl.agg.call_stats)
    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (typically generated using annotate_freq)
    :param locus: locus
    :param gen_anc_groups_to_exclude: Set of genetic ancestry groups to exclude from faf calculation (typically bottlenecked or consanguineous genetic ancestry groups)
    :param faf_thresholds: List of FAF thresholds to compute
    :param gen_anc_label: Label of the genetic ancestry group field in the meta dictionary
    :return: (FAF expression, FAF metadata)
    """
    _gen_anc_groups_to_exclude = (
        hl.literal(gen_anc_groups_to_exclude) if gen_anc_groups_to_exclude is not None else hl.empty_set(hl.tstr)
    )

    # pylint: disable=invalid-unary-operand-type
    faf_freq_indices = hl.range(0, hl.len(freq_meta)).filter(
        lambda i: (freq_meta[i].get("group") == "adj")
        & (
            (freq_meta[i].size() == 1)
            | (
                (hl.set(freq_meta[i].keys()) == {gen_anc_label, "group"})
                & (~_gen_anc_groups_to_exclude.contains(freq_meta[i][gen_anc_label]))
            )
        ),
    )
    sex_faf_freq_indices = hl.range(0, hl.len(freq_meta)).filter(
        lambda i: (freq_meta[i].get("group") == "adj")
        & (freq_meta[i].contains("sex"))
        & (
            (freq_meta[i].size() == 2)
            | (
                (hl.set(freq_meta[i].keys()) == {gen_anc_label, "group", "sex"})
                & (~_gen_anc_groups_to_exclude.contains(freq_meta[i][gen_anc_label]))
            )
        ),
    )

    faf_expr = faf_freq_indices.map(
        lambda i: hl.struct(
            **{
                f"faf{str(threshold)[2:]}": hl.experimental.filtering_allele_frequency(
                    freq[i].AC,
                    freq[i].AN,
                    threshold,
                )
                for threshold in faf_thresholds
            },
        ),
    )

    faf_expr = faf_expr.extend(
        sex_faf_freq_indices.map(
            lambda i: hl.or_missing(
                ~locus.in_autosome_or_par(),
                hl.struct(
                    **{
                        f"faf{str(threshold)[2:]}": (
                            hl.experimental.filtering_allele_frequency(freq[i].AC, freq[i].AN, threshold)
                        )
                        for threshold in faf_thresholds
                    },
                ),
            ),
        ),
    )

    faf_meta = faf_freq_indices.extend(sex_faf_freq_indices).map(lambda i: freq_meta[i])
    return faf_expr, hl.eval(faf_meta)


def grpmax_expr(
    freq: hl.expr.ArrayExpression,
    freq_meta: hl.expr.ArrayExpression,
    gen_anc_groups_to_exclude: Optional[Set[str]] = None,
    gen_anc_label: str = "gen_anc",
) -> hl.expr.StructExpression:
    """

    Create an expression containing the frequency information about the genetic ancestry group that has the highest AF in `freq_meta`.

    Genetic ancestry groups specified in `gen_anc_groups_to_exclude` are excluded and only frequencies from adj genetic ancestry groups are considered.

    This resulting struct contains the following fields:

        - AC: int32
        - AF: float64
        - AN: int32
        - homozygote_count: int32
        - gen_anc: str

    :param freq: ArrayExpression of Structs with fields ['AC', 'AF', 'AN', 'homozygote_count']
    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (as returned by annotate_freq)
    :param gen_anc_groups_to_exclude: Set of genetic ancestry groups to skip for genetic ancestry max calculation
    :param gen_anc_label: Label of the genetic ancestry group field in the meta dictionary
    :return: Genetic ancestry max struct
    """
    _gen_anc_groups_to_exclude = (
        hl.literal(gen_anc_groups_to_exclude) if gen_anc_groups_to_exclude is not None else hl.empty_set(hl.tstr)
    )

    # pylint: disable=invalid-unary-operand-type
    gen_anc_max_freq_indices = hl.range(0, hl.len(freq_meta)).filter(
        lambda i: (hl.set(freq_meta[i].keys()) == {"group", gen_anc_label})
        & (freq_meta[i]["group"] == "adj")
        & (~_gen_anc_groups_to_exclude.contains(freq_meta[i][gen_anc_label])),
    )
    freq_filtered = gen_anc_max_freq_indices.map(
        lambda i: freq[i].annotate(**{gen_anc_label: freq_meta[i][gen_anc_label]}),
    ).filter(lambda f: f.AC > 0)

    sorted_freqs = hl.sorted(freq_filtered, key=lambda x: x.AF, reverse=True)
    return hl.or_missing(hl.len(sorted_freqs) > 0, sorted_freqs[0])


def extract_freq_info(ht: hl.Table, prefix: str, apply_release_filters: bool = True) -> hl.Table:
    """
    Extract frequencies and FAF for adj, raw (only for frequencies), adj by pop, adj by sex, and adj by pop/sex.

    The following annotations are renamed and where applicable, filtered:
        - freq: {prefix}_freq
        - faf: {prefix}_faf
        - grpmax: {prefix}_grpmax
        - fafmax: {prefix}_fafmax
        - qual_hists: {prefix}_qual_hists
        - raw_qual_hists: {prefix}_raw_qual_hists
        - age_hists: {prefix}_age_hists

    The following global annotations are filtered and renamed:
        - freq_meta: {prefix}_freq_meta
        - freq_index_dict: {prefix}_freq_index_dict
        - faf_meta: {prefix}_faf_meta
        - faf_index_dict: {prefix}_faf_index_dict
        - age_distribution: {prefix}_age_distribution

    If `apply_release_filters` is True, a {prefix}_filters annotation is added to the Table and the following variants are filtered:
        - chrM
        - AS_lowqual sites (these sites are dropped in the
          final_filters HT so will not have information in `filters`,
          hl.is_defined(ht.filters) is used)
        - AC_raw == 0

    :param ht: Table with frequency and FAF information.
    :param prefix: Prefix to add to each of the filtered annotations.
    :param apply_release_filters: Whether to apply the final release filters to the
        Table. Default is True.
    :return: Table with filtered frequency and FAF information.
    """
    if apply_release_filters:
        # Filter out chrM, AS_lowqual sites (these sites are dropped in the
        # final_filters HT so will not have information in `filters`) and AC_raw == 0.
        ht = hl.filter_intervals(ht, [hl.parse_locus_interval("chrM")], keep=False)
        ht = ht.filter(hl.is_defined(ht.filters) & (ht.freq[1].AC > 0))

    logger.info("Keeping only frequencies for adj, raw, adj by pop, adj by sex, and adj by " "pop/sex...")
    freq_meta, array_exprs = filter_arrays_by_meta(
        ht.freq_meta,
        {
            "freq": ht.freq,
            "freq_meta_sample_count": ht.index_globals().freq_meta_sample_count,
        },
        ["group", "pop", "sex"],
        combine_operator="or",
        exact_match=True,
    )
    freq_index_dict = make_freq_index_dict_from_meta(hl.literal(freq_meta))
    logger.info("Keeping only FAF for adj, adj by pop, adj by sex, and adj by pop/sex...")
    # Exomes FAF was calculated for the whole gnomad and the ukb subset, we only
    # want to include the whole dataset in the joint release.
    faf_meta, faf = filter_arrays_by_meta(
        ht.faf_meta,
        {"faf": ht.faf},
        ["group", "pop", "sex"],
        combine_operator="or",
        exact_match=True,
    )
    faf_index_dict = make_freq_index_dict_from_meta(hl.literal(faf_meta))

    # Select grpmax and fafmax
    grpmax_expr = ht.popmax
    fafmax_expr = ht.fafmax

    # Drop 'faf95' annotation in the grpmax_expr if it exists. We no longer add this to
    # releases.
    if "faf95" in grpmax_expr:
        grpmax_expr = grpmax_expr.drop("faf95")

    # Rename filtered annotations with supplied prefix.
    ht = ht.select(
        **{f"{prefix}_filters": ht.filters} if apply_release_filters else {},
        **{
            f"{prefix}_freq": array_exprs["freq"],
            f"{prefix}_faf": faf["faf"],
            f"{prefix}_grpmax": grpmax_expr,
            f"{prefix}_fafmax": fafmax_expr,
            f"{prefix}_qual_hists": ht.histograms.qual_hists,
            f"{prefix}_raw_qual_hists": ht.histograms.raw_qual_hists,
            f"{prefix}_age_hists": ht.histograms.age_hists,
        },
    )
    ht = ht.select_globals(
        **{
            f"{prefix}_freq_meta": freq_meta,
            f"{prefix}_freq_index_dict": freq_index_dict,
            f"{prefix}_freq_meta_sample_count": array_exprs["freq_meta_sample_count"],
            f"{prefix}_faf_meta": faf_meta,
            f"{prefix}_faf_index_dict": faf_index_dict,
            f"{prefix}_age_distribution": ht.age_distribution,
        },
    )

    ht = ht.checkpoint(hl.utils.new_temp_file("extract_freq_info", "ht"))

    return ht


def missing_callstats_expr() -> hl.expr.StructExpression:
    """
    Create a missing callstats struct for insertion into frequency annotation arrays when data is missing.

    :return: Hail Struct with missing values for each callstats element
    """
    return hl.struct(
        AC=hl.missing(hl.tint32),
        AF=hl.missing(hl.tfloat64),
        AN=hl.missing(hl.tint32),
        homozygote_count=hl.missing(hl.tint32),
    )


def set_xx_y_metrics_to_na_expr(
    t: Union[hl.Table, hl.MatrixTable],
    freq_expr: Union[hl.expr.ArrayExpression, str] = "freq",
    freq_meta_expr: Union[hl.expr.ArrayExpression, str] = "freq_meta",
    freq_index_dict_expr: Union[hl.expr.DictExpression, str] = "freq_index_dict",
) -> hl.expr.ArrayExpression:
    """
    Set Y-variant frequency callstats for XX-specific metrics to missing structs.

    :param t: Table or MatrixTable for which to adjust XX metrics.
    :param freq_expr: Array expression or string annotation name for the frequency
        array. Default is "freq".
    :param freq_meta_expr: Array expression or string annotation name for the frequency
        metadata. Default is "freq_meta".
    :param freq_index_dict_expr: Dict expression or string annotation name for the
        frequency metadata index dictionary. Default is "freq_index_dict".
    :return: Hail array expression to set XX Y-variant metrics to missing values.
    """
    if isinstance(freq_expr, str):
        freq_expr = t[freq_expr]
    if isinstance(freq_meta_expr, str):
        freq_meta_expr = t[freq_meta_expr]
    if isinstance(freq_index_dict_expr, str):
        freq_index_dict_expr = t[freq_index_dict_expr]

    xx_idx = hl.map(
        lambda x: freq_index_dict_expr[x],
        hl.filter(lambda x: x.contains("XX"), freq_index_dict_expr.keys()),
    )
    freq_idx_range = hl.range(hl.len(freq_meta_expr))

    new_freq_expr = hl.if_else(
        (t.locus.in_y_nonpar() | t.locus.in_y_par()),
        hl.map(
            lambda x: hl.if_else(xx_idx.contains(x), missing_callstats_expr(), freq_expr[x]),
            freq_idx_range,
        ),
        freq_expr,
    )

    return new_freq_expr


def add_all_sites_an_and_qual_hists(
    ht: hl.Table,
    exomes_all_sites_ht: hl.Table,
    genomes_all_sites_ht: hl.Table,
) -> hl.Table:
    """
    Add all sites AN and qual hists to the Table.

    :param ht: Table with frequency and FAF information.
    :param exomes_all_sites_ht: Table with all sites AN and qual hists for exomes.
    :param genomes_all_sites_ht: Table with all sites AN and qual hists for genomes.
    :return: Table with all sites AN and qual hists added.
    """

    def _get_freq_from_an_expr(
        freq_expr: hl.expr.ArrayExpression,
        all_sites_an_expr: hl.expr.ArrayExpression,
        freq_meta_expr: hl.expr.ArrayExpression,
        freq_index_dict_expr: hl.expr.DictExpression,
        an_meta_expr: hl.expr.ArrayExpression,
    ) -> hl.expr.ArrayExpression:
        """
        Get freq expression with all sites AN added if `freq_expr` is missing.

        :param freq_expr: ArrayExpression of frequencies.
        :param all_sites_an_expr: ArrayExpression of all sites AN.
        :param freq_meta_expr: Frequency metadata.
        :param freq_index_dict_expr: Frequency index dictionary.
        :param an_meta_expr: AN metadata.
        :return: ArrayExpression of frequencies with all sites AN added if `freq_expr`
            is missing.
        """
        meta_map = hl.dict(hl.enumerate(an_meta_expr).map(lambda x: (x[1], x[0])))
        all_sites_an_expr = freq_meta_expr.map(
            lambda x: hl.bind(
                lambda an: hl.struct(
                    AC=hl.or_missing(hl.is_defined(an), 0),
                    AF=hl.or_missing(an > 0, hl.float64(0.0)),
                    AN=hl.int32(an),
                    homozygote_count=hl.or_missing(hl.is_defined(an), 0),
                ),
                all_sites_an_expr[meta_map[x]],
            ),
        )
        logger.info("Setting XX samples call stats to missing on chrY...")
        all_sites_an_expr = set_xx_y_metrics_to_na_expr(
            ht,
            freq_expr=all_sites_an_expr,
            freq_meta_expr=freq_meta_expr,
            freq_index_dict_expr=freq_index_dict_expr,
        )

        return hl.coalesce(freq_expr, all_sites_an_expr)

    logger.info("Adding all sites AN and qual hists information where missing...")
    all_sites_by_data_type = {
        "exomes": exomes_all_sites_ht[ht.locus],
        "genomes": genomes_all_sites_ht[ht.locus],
    }
    all_sites_meta_by_data_type = {
        "exomes": exomes_all_sites_ht.index_globals().strata_meta,
        "genomes": genomes_all_sites_ht.index_globals().strata_meta,
    }
    ht = ht.annotate(
        **{
            f"{data_type}_freq": _get_freq_from_an_expr(
                ht[f"{data_type}_freq"],
                all_sites.AN,
                ht.index_globals()[f"{data_type}_freq_meta"],
                ht.index_globals()[f"{data_type}_freq_index_dict"],
                all_sites_meta_by_data_type[data_type],
            )
            for data_type, all_sites in all_sites_by_data_type.items()
        },
        **{
            f"{data_type}_{adj}qual_hists": hl.struct(
                **{
                    k: hl.coalesce(
                        ht[f"{data_type}_{adj}qual_hists"][k],
                        all_sites.qual_hists[f"{adj}qual_hists"].get(
                            k,
                            hl.missing(
                                hl.tstruct(
                                    bin_edges=hl.tarray(hl.tfloat64),
                                    bin_freq=hl.tarray(hl.tint64),
                                    n_smaller=hl.tint64,
                                    n_larger=hl.tint64,
                                ),
                            ),
                        ),
                    )
                    for k in ht[f"{data_type}_{adj}qual_hists"]
                },
            )
            for data_type, all_sites in all_sites_by_data_type.items()
            for adj in ["", "raw_"]
        },
    )

    return ht


def get_joint_freq_and_faf(
    genomes_ht: hl.Table,
    exomes_ht: hl.Table,
    genomes_all_sites_ht: hl.Table,
    exomes_all_sites_ht: hl.Table,
    faf_pops_to_exclude: Set[str] = GEN_ANC_GROUPS_TO_REMOVE_FOR_GRPMAX,
) -> hl.Table:
    """
    Get joint genomes and exomes frequency and FAF information.

    :param genomes_ht: Table with genomes frequency and FAF information.
    :param exomes_ht: Table with exomes frequency and FAF information.
    :param genomes_all_sites_ht: Table with all sites AN and qual hists for genomes.
    :param exomes_all_sites_ht: Table with all sites AN and qual hists for exomes.
    :param faf_pops_to_exclude: Set of genetic ancestry groups to exclude from the FAF
        calculation.
    :return: Table with joint genomes and exomes frequency and FAF information.
    """
    logger.info("Performing an outer join on frequency HTs...")
    ht = genomes_ht.join(exomes_ht, how="outer")
    ht = add_all_sites_an_and_qual_hists(ht, exomes_all_sites_ht, genomes_all_sites_ht)

    # Merge exomes and genomes frequencies.
    freq, freq_meta, count_arrays_dict = merge_freq_arrays(
        farrays=[ht.genomes_freq, ht.exomes_freq],
        fmeta=[
            ht.index_globals().genomes_freq_meta,
            ht.index_globals().exomes_freq_meta,
        ],
        count_arrays={
            "counts": [
                ht.index_globals().genomes_freq_meta_sample_count,
                ht.index_globals().exomes_freq_meta_sample_count,
            ],
        },
    )

    ht = ht.annotate(
        joint_freq=freq,
        **{
            f"joint_{hist_struct}": hl.struct(
                **{
                    h: merge_histograms([ht[f"{d}_{hist_struct}"][h] for d in DATA_TYPES])
                    for h in ht[f"genomes_{hist_struct}"]
                },
            )
            for hist_struct in ["qual_hists", "raw_qual_hists", "age_hists"]
        },
    )
    ht = ht.annotate_globals(
        joint_freq_meta=freq_meta,
        joint_freq_index_dict=make_freq_index_dict_from_meta(hl.literal(freq_meta)),
    )
    # NOTE: This checkpoint prevents a Class Too Large error in hail 0.2.122.
    ht = ht.checkpoint(hl.utils.new_temp_file("combine_faf", "ht"))

    logger.info("Setting Y metrics to NA for XX groups...")
    freq = set_xx_y_metrics_to_na_expr(
        ht,
        freq_expr=ht.joint_freq,
        freq_meta_expr=ht.joint_freq_meta,
        freq_index_dict_expr=ht.joint_freq_index_dict,
    )
    ht = ht.annotate(joint_freq=freq)

    # Compute FAF on the merged exomes + genomes frequencies.
    faf, faf_meta = faf_expr(
        ht.joint_freq,
        ht.joint_freq_meta,
        ht.locus,
        gen_anc_groups_to_exclude=faf_pops_to_exclude,
        gen_anc_label="pop",
    )

    # Compute group max (popmax) on the merged exomes + genomes frequencies.
    grpmax = grpmax_expr(
        ht.joint_freq,
        ht.joint_freq_meta,
        gen_anc_groups_to_exclude=faf_pops_to_exclude,
        gen_anc_label="pop",
    )

    # Annotate Table with all joint exomes + genomes computations.
    ht = ht.annotate(
        joint_faf=faf,
        joint_fafmax=gen_anc_faf_max_expr(faf, hl.literal(faf_meta), gen_anc_label="pop"),
        joint_grpmax=grpmax,
    )

    ht = ht.annotate_globals(
        joint_faf_meta=faf_meta,
        joint_faf_index_dict=make_freq_index_dict_from_meta(hl.literal(faf_meta)),
        joint_freq_meta_sample_count=count_arrays_dict["counts"],
        joint_age_distribution=merge_histograms([ht.genomes_age_distribution, ht.exomes_age_distribution]),
    )

    return ht


def perform_contingency_table_test(
    freq1_expr: hl.expr.ArrayExpression,
    freq2_expr: hl.expr.ArrayExpression,
    freq1_meta_expr: hl.expr.ArrayExpression,
    freq2_meta_expr: hl.expr.ArrayExpression,
    joint_meta_expr: hl.expr.ArrayExpression,
    min_cell_count: int = 5,
) -> hl.expr.ArrayExpression:
    """
    Perform Hail's `contingency_table_test` on the alleles counts between two frequency expressions.

    This is done on the 2x2 matrix of reference and alternate allele counts. The
    chi-squared test is used for any case where all cells of the 2x2 matrix are greater
    than `min_cell_count`. Otherwise, Fisher’s exact test is used.

    `freq1_expr` and `freq2_expr` should be ArrayExpressions of structs with 'AN' and
    'AC' annotations.

    .. note::

        The order of the output array expression will be the same as `joint_meta_expr`
        and any frequency group with missing or zero AC in both `freq1_expr` and
        `freq2_expr` (based on `freq1_meta_expr` and `freq2_meta_expr`) will be set to
        missing. Any frequency group in `freq1_meta_expr` or `freq2_meta_expr` that is
        not in `joint_meta_expr` will be excluded from tests.

    :param freq1_expr: First ArrayExpression of frequencies to combine.
    :param freq2_expr: Second ArrayExpression of frequencies to combine.
    :param freq1_meta_expr: Frequency metadata for `freq1_expr`.
    :param freq2_meta_expr: Frequency metadata for `freq2_expr`.
    :param joint_meta_expr: Joint frequency metadata, only used for ordering the output
        array expression.
    :param min_cell_count: Minimum count in every cell to use the chi-squared test.
        Default is 5.
    :return: ArrayExpression for contingency table test results.
    """
    # Using the joint_meta_expr to get the indexes of the two frequency expressions.
    freq_meta_idx = joint_meta_expr.map(lambda x: (freq1_meta_expr.index(x), freq2_meta_expr.index(x)))

    logger.info("Computing chi squared and fisher exact tests on frequencies...")
    # If both frequency structs are defined and at least one AC is greater than 0,
    # compute the chi-squared test otherwise return missing.
    return freq_meta_idx.map(
        lambda x: hl.or_missing(
            hl.is_defined(x[0]) & hl.is_defined(x[1]),
            hl.bind(
                lambda f1, f2: hl.or_missing(
                    (f1.AC > 0) | (f2.AC > 0) & (f1.AN > 0) & (f2.AN > 0),
                    hl.contingency_table_test(f1.AC, f1.AN - f1.AC, f2.AC, f2.AN - f2.AC, min_cell_count),
                ),
                freq1_expr[x[0]],
                freq2_expr[x[1]],
            ),
        ),
    )


def perform_cmh_test(
    ht: hl.Table,
    freq1_expr: hl.expr.ArrayExpression,
    freq2_expr: hl.expr.ArrayExpression,
    freq1_meta_expr: hl.expr.ArrayExpression,
    freq2_meta_expr: hl.expr.ArrayExpression,
    pops: List[str],
) -> hl.Table:
    """
    Perform the Cochran–Mantel–Haenszel test on the alleles counts between two frequency expressions using genetic ancestry group as the stratification.

    This is done by creating a list of 2x2 matrices of freq1/freq2 reference and
    alternate allele counts for each genetic ancestry group in pops. The stats used in
    `perform_contingency_table_test` can only be used on 2x2 matrices, so we perform
    that per genetic ancestry group to get one statistic per genetic ancestry group.
    The CMH test allows for multiple 2x2 matrices for a specific stratification, giving
    a single statistic across all genetic ancestry groups.

    `freq1_expr` and `freq2_expr` should be ArrayExpressions of structs with 'AN' and
    'AC' annotations.

    .. note::

        Any genetic ancestry group with zero AC in both `freq1_expr` and `freq2_expr`
        will be excluded from the test.

    :param ht: Table with joint exomes and genomes frequency and FAF information.
    :param freq1_expr: First ArrayExpression of frequencies to combine.
    :param freq2_expr: Second ArrayExpression of frequencies to combine.
    :param freq1_meta_expr: Frequency metadata for `freq1_expr`.
    :param freq2_meta_expr: Frequency metadata for `freq2_expr`.
    :param pops: List of genetic ancestry groups to include in the CMH test.
    :return: ArrayExpression for Cochran–Mantel–Haenszel test results.
    """

    def _get_freq_by_pop(
        freq_expr: hl.expr.ArrayExpression,
        meta_expr: hl.expr.ArrayExpression,
    ) -> Dict[str, hl.expr.StructExpression]:
        """
        Get a dictionary of frequency StructExpressions by genetic ancestries.

        :param freq_expr: ArrayExpression of frequencies to combine.
        :param meta_expr: Frequency metadata for `freq_expr`.
        :return: Dictionary of frequency StructExpressions by genetic ancestry group.
        """
        return {
            m.get("pop"): freq_expr[i] for i, m in enumerate(hl.eval(meta_expr)) if m.get("pop") in pops and len(m) == 2
        }

    freq1_by_pop = _get_freq_by_pop(freq1_expr, freq1_meta_expr)
    freq2_by_pop = _get_freq_by_pop(freq2_expr, freq2_meta_expr)

    # Create list of the info for the 2x2 matrices of reference and alternate allele
    # counts for each genetic ancestry group in pops and remove any missing pops
    # from the list.
    cmh_input_expr = hl.array(
        [
            hl.bind(
                lambda x, y: hl.or_missing(
                    ((x.AC > 0) | (y.AC > 0)) & (x.AN > 0) & (y.AN > 0),
                    ([x.AC, x.AN - x.AC, y.AC, y.AN - y.AC], pop),
                ),
                freq1_by_pop[pop],
                freq2_by_pop[pop],
            )
            for pop in pops
        ],
    ).filter(hl.is_defined)

    return hl.or_missing(
        hl.len(cmh_input_expr) > 0,
        hl.cochran_mantel_haenszel_test(*[cmh_input_expr.map(lambda x: x[0][i]) for i in range(4)])
        .annotate(gen_ancs=cmh_input_expr.map(lambda x: x[1]))
        .rename({"test_statistic": "chisq"}),
    )


def run(
    genome_freq_ht_path: str,
    exome_freq_ht_path: str,
    genome_all_sites_path: str,
    exome_all_sites_path: str,
    out_ht_path: str,
):
    """
    Run the joint frequencies workflow.
    """
    if can_reuse(out_ht_path):
        return None

    genome_freq_ht = hl.read_table(str(genome_freq_ht_path))
    exome_freq_ht = hl.read_table(str(exome_freq_ht_path))
    genome_all_sites_ht = hl.read_table(str(genome_all_sites_path))
    exome_all_sites_ht = hl.read_table(str(exome_all_sites_path))

    # TODO (from gnomad): Need to resolve the type difference.
    genome_freq_ht = genome_freq_ht.annotate(
        freq=genome_freq_ht.freq.map(lambda x: x.annotate(homozygote_count=hl.int32(x.homozygote_count))),
    )
    exome_freq_ht = exome_freq_ht.annotate(
        freq=exome_freq_ht.freq.map(lambda x: x.annotate(homozygote_count=hl.int32(x.homozygote_count))),
    )

    exome_freq_ht = extract_freq_info(exome_freq_ht, "exomes", apply_release_filters=False)
    genome_freq_ht = extract_freq_info(genome_freq_ht, "genomes", apply_release_filters=False)

    ht = get_joint_freq_and_faf(
        genome_freq_ht,
        exome_freq_ht,
        genome_all_sites_ht,
        exome_all_sites_ht,
    )
    ht = ht.annotate_globals(
        versions=hl.struct(
            exomes='1.0',
            genomes='1.0',
        ),
    )

    # Perform contingency table test for joint frequencies.
    # NOTE: Do we need to filter out any joint frequencies that are missing?
    ht = ht.filter(hl.is_defined(ht.genomes_freq) & hl.is_defined(ht.exomes_freq))

    ht = ht.annotate(
        contingency_table_test=perform_contingency_table_test(
            ht.genomes_freq,
            ht.exomes_freq,
            ht.genomes_freq_meta,
            ht.exomes_freq_meta,
            ht.joint_freq_meta,
            min_cell_count=5,
        ),
    )

    # Perform Cochran-Mantel-Haenszel test for joint frequencies.
    ht = ht.filter(hl.is_defined(ht.genomes_freq) & hl.is_defined(ht.exomes_freq))
    ht = ht.annotate(
        cochran_mantel_haenszel_test=perform_cmh_test(
            ht,
            ht.genomes_freq,
            ht.exomes_freq,
            ht.genomes_freq_meta,
            ht.exomes_freq_meta,
            pops=FAF_POPS,
        ),
    )

    return ht.checkpoint(out_ht_path, overwrite=True)
